#
# HDF5-UDF: User-Defined Functions for HDF5
#
# File: udf_template.py
#
# HDF5 filter callbacks and main interface with the Python API.
#

# Note: backend_python.cpp loads the "cffi" module for us. By delegating that
# task to the C code we can keep strict sandboxing rules, as the import process
# requires access to the filesystem (i.e., readdir, stat, open, etc)

class PythonLib:
    """Interfaces between User-Defined Functions and the HDF5 API."""

    def __init__(self):
        pass

    def load(self, libpath):
        # self.cffi is initialized from C code
        # self.ffi = cffi.FFI()

        self.ffi.cdef("""
            void       *pythonGetData(const char *);
            const char *pythonGetType(const char *);
            const char *pythonGetCast(const char *);
            const char *pythonGetDims(const char *);
            const char *pythonGetFilePath(void);
            // compound_declarations_placeholder
            """, packed=True)

        # self.udflib is initialized from C code
        # self.udflib = self.ffi.dlopen(libpath)

    def getFilePath(self):
        """Retrieve the path to the input HDF5 file.
        """
        return self.ffi.string(self.udflib.pythonGetFilePath())

    def string(self, structure):
        """Retrieve the value of a HDF5 string datatype.

        Parameters
        ----------
        structure: obj
            Object holding the string element to be retrieved

        Examples
        --------
        Print the i-th member of a string datatype

        .. code-block::

            print(lib.string(item[i], flush=True))

        Returns
        -------
        str
            The string element (decoded from UTF-8)
        """
        # Strings are embedded in a structure with a single 'value' member
        if hasattr(structure, "value"):
            return self.ffi.string(structure.value).decode("utf-8")
        # The user may also provide a direct pointer to the string member
        return self.ffi.string(structure).decode("utf-8")

    def setString(self, structure, s):
        """Set the value of a HDF5 string datatype.

        Write the given string to the provided object. No encoding assumptions
        are made; the application is expected to encode() the given string.
        This function does boundary checks to prevent buffer overflows.

        Parameters
        ----------
        structure: obj
            String object whose value is to be set

        s: str
            String value to write to the given object

        Examples
        --------
        Write to the i-th member of a string datatype

        .. code-block::

            lib.setString(item[i], "Too much monkey business".encode("utf-8"))

        Write a string to a compound member 'album'

        .. code-block::

            lib.setString(item[i].album, "Electric Ladyland".encode("utf-8"))
        """
        if hasattr(structure, "value"):
            n = len(s) if len(s) <= len(structure.value) else len(structure.value)
            structure.value[0:n] = s[0:n]
        else:
            n = len(s) if len(s) <= len(structure) else len(structure)
            structure[0:n] = s[0:n]

    def getData(self, name):
        """Get a data pointer to the given dataset.

        This method fetches the given dataset name from the HDF5 file and loads
        it into memory. If the given name refers to a dataset that the UDF uses
        as input, the returned object holds the contents (values) of that
        dataset. Otherwise, if the given name is the output dataset being
        programmatically generated by the function, then the returned object is
        theh actual buffer which the user-defined function needs to populate.

        Parameters
        ----------
        name: str
            Dataset name

        Examples
        --------
        Retrieve pointers to the input and output dataset, then copy the first
        100 elements of the input dataset to the output. Note that start and
        end indexes must always be provided when reading or writing data to
        data retrieved by this API.

        .. code-block::

            input_ds = lib.getData("input_dataset")
            output_ds = lib.getData("output_dataset")
            input_ds[0:100] = output_ds[0:100]

        Returns
        -------
        obj
            Data pointer to the requested dataset
        """
        name = self.ffi.new("char[]", name.encode("utf-8"))
        cast = self.udflib.pythonGetCast(name)
        data = self.udflib.pythonGetData(name)
        ctype = self.ffi.string(cast).decode("utf-8")
        return self.ffi.cast(ctype, data)

    def getType(self, name):
        """Get the data type of the given dataset.

        Parameters
        ----------
        name: str
            Dataset name

        Returns
        -------
        str
            The corresponding data type name. The following is a list of
            possible values returned by this function: "int8", "int16",
            "int32", "int64", "uint8", "uint16", "uint32", "uint64",
            "float", "double", "compound", and "string".
        """
        name = self.ffi.new("char[]", name.encode("utf-8"))
        return self.ffi.string(self.udflib.pythonGetType(name))

    def getDims(self, name):
        """Get the dimensions of the given dataset.

        Parameters
        ----------
        name: str
            Dataset name

        Returns
        -------
        list
            A list of integers containing the size of each dimension of the
            given dataset.
        """
        name = self.ffi.new("char[]", name.encode("utf-8"))
        dims = self.udflib.pythonGetDims(name)
        dims = self.ffi.string(dims).decode("utf-8")
        return tuple([int(dim) for dim in dims.split("x")])

lib = PythonLib()

# User-Defined Function

# user_callback_placeholder
